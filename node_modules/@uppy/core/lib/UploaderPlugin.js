function _classPrivateFieldLooseBase(receiver, privateKey) { if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) { throw new TypeError("attempted to use private field on non-instance"); } return receiver; }
var id = 0;
function _classPrivateFieldLooseKey(name) { return "__private_" + id++ + "_" + name; }
import BasePlugin from './BasePlugin.js';
var _queueRequestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey("queueRequestSocketToken");
export default class UploaderPlugin extends BasePlugin {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, _queueRequestSocketToken, {
      writable: true,
      value: void 0
    });
  }
  /** @protected */
  setQueueRequestSocketToken(fn) {
    _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken] = fn;
  }
  async uploadRemoteFile(file, options) {
    if (options === void 0) {
      options = {};
    }
    // TODO: we could rewrite this to use server-sent events instead of creating WebSockets.
    try {
      if (file.serverToken) {
        return await this.connectToServerSocket(file);
      }
      const serverToken = await _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken](file).abortOn(options.signal);
      if (!this.uppy.getState().files[file.id]) return undefined;
      this.uppy.setFileState(file.id, {
        serverToken
      });
      return await this.connectToServerSocket(this.uppy.getFile(file.id));
    } catch (err) {
      var _err$cause;
      if ((err == null ? void 0 : (_err$cause = err.cause) == null ? void 0 : _err$cause.name) === 'AbortError') {
        // The file upload was aborted, itâ€™s not an error
        return undefined;
      }
      this.uppy.setFileState(file.id, {
        serverToken: undefined
      });
      this.uppy.emit('upload-error', file, err);
      throw err;
    }
  }
}